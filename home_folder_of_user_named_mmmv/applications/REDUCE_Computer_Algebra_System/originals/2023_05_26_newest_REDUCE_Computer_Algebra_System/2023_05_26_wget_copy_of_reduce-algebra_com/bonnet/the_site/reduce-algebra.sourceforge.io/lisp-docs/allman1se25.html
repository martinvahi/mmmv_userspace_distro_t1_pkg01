<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Function Definition in PSL</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,html --> 
<meta name="src" content="allman1.tex"> 
<meta name="date" content="2014-05-02 18:10:00"> 
<link rel="stylesheet" type="text/css" href="allman1.css"> 
</head><body 
>
<p align="centre"><img src="https://reduce-algebra.sourceforge.io/lisp-docs/redlogo.png" width=621 height=60 border=0 alt="REDUCE"></p><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li7.html#allman1se25.html" >Up</a></td><td class="clinks"><a 
href="allman1se26.html" >Next</a></td><td class="clinks"><a 
href="allman1se25.html#tailallman1se25.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">8.1    </span> <a 
 id="x35-870008.1"></a>Function Definition in PSL</h3>
<!--l. 5--><p class="noindent" >Functions in PSL are global entities. To avoid function-variable naming clashes, the Standard
LISP Report required that no variable have the same name as a function. There is no conflict in
PSL, as separate function cells and value cells are used.
<!--l. 11--><p class="noindent" >The first major section in this chapter describes how to define new functions; the second
describes the binding of variables in PSL. The final section presents binding functions useful in
building new interpreter functions.
<!--l. 16--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">8.1.1    </span> <a 
 id="x35-880008.1.1"></a>Function Types</h4>
<!--l. 18--><p class="noindent" >Eval-type functions are those called with evaluated arguments. NoEval functions are called with
unevaluated arguments. Spread-type functions have their arguments passed in a one-to-one
correspondence with their formal parameters. NoSpread functions receive their arguments as a
single list.

<!--l. 24--><p class="noindent" >There are four function types implemented in PSL:<br 
class="newline" />
<div class="tabular"><table id="TBL-6" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-6-1g"><col 
id="TBL-6-1"><col 
id="TBL-6-2"></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-6-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-1-1"  
class="td11">expr  </td><td  style="white-space:wrap; text-align:left;" id="TBL-6-1-2"  
class="td11"><!--l. 28--><p class="noindent" >An  Eval,  Spread  function,  with  a  maximum  number  of  arguments.  The
maximum  depends  upon  the  implementation.  In  referring  to  the  formal
parameters we mean their values. Each function of this type should always
be  called  with  the  expected  number  of  parameters,  as  indicated  in  the
function definition.                                                                                        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-2-1"  
class="td11">fexpr  </td><td  style="white-space:wrap; text-align:left;" id="TBL-6-2-2"  
class="td11"><!--l. 36--><p class="noindent" >A  NoEval,  NoSpread  function.  There  is  no  limit  on  the  number  of
arguments. In referring to the formal parameters we mean the unevaluated
arguments,  collected  as  a  single  list,  and  passed  as  a  single  formal
parameter to the function body.                                                                    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-3-1"  
class="td11">nexpr </td><td  style="white-space:wrap; text-align:left;" id="TBL-6-3-2"  
class="td11"><!--l. 42--><p class="noindent" >An Eval, NoSpread function. Each call on this kind of function may present
a different number of arguments, which are evaluated, collected into a list,
and passed in to the function body as a single formal parameter.                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-4-1"  
class="td11">macro</td><td  style="white-space:wrap; text-align:left;" id="TBL-6-4-2"  
class="td11"><!--l. 48--><p class="noindent" >The macro is a function which creates a new S-expression for subsequent
evaluation or compilation. There is no limit to the number of arguments
a macro may have. The descriptions of the eval and expand functions in
Chapter 11 provide precise details.                                                               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-5-1"  
class="td11">    </td></tr></table></div>
<h4 class="subsectionHead"><span class="titlemark">8.1.2    </span> <a 
 id="x35-890008.1.2"></a>Notes on Code Pointers</h4>
<!--l. 57--><p class="noindent" >A code-pointer may be displayed by the print functions or expanded by explode. The value
appears in the convention of the implementation e.g. (#<span 
class="cmmi-12">&#x003C;</span>Code:A N<span 
class="cmmi-12">&#x003E;</span>, where A is the number of
arguments of the function, and N is the function&#8217;s entry point). A code-pointer may not be
created by compress. (See Chapter 12 for descriptions of explode and compress.) The
code-pointer associated with a compiled function may be retrieved by getd and is valid as long
as PSL is in execution. Normally a code-pointer is stored using putd. It may be checked for
equivalence by eq. The value may be checked for being a code-pointer by the codep
function.
<!--l. 69--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">8.1.3    </span> <a 
 id="x35-900008.1.3"></a>Functions Useful in Function Definition</h4>
<!--l. 71--><p class="noindent" >In PSL, ids have a function cell that usually contains an executable instruction which either
JUMPs directly to the entry point of a compiled function or executes a CALL to an auxiliary
routine that handles interpreted functions, undefined functions, or other special services (such as
auto-loading functions, etc). The user can pass anonymous function objects around either as a
code-pointer, which is a tagged object referring to a compiled code block, or a lambda
expression, representing an interpreted function.

<!--l. 88--><p class="noindent" ><div class="minipage"><a 
 id="dx35-90001"></a>
<span 
class="ptmb7t-x-x-120">(putd Fname:id TYPE:ftype BODY:</span><br 
class="newline" /><span 
class="ptmb7t-x-x-120">lambda,code-pointer):id                                                                                              </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Creates  a  function  with  name  Fname  and  type  TYPE,  with  body  as  the
function  definition.  If  successful,  putd  returns  the  name  of  the  defined
function.</div></div>
<!--l. 90--><p class="noindent" >If the body is a lambda there are two possible outcomes. When the switch comp is set
to t the body will be compiled and a special instruction to jump to the start of the
code is placed in the function cell. If the switch *comp is set to nil then the body is
saved on the property list under the indicator *lambdalink and a call to an interpreter
function

<div class="verbatim" id="verbatim-246">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(lambdalink)&#x00A0;is&#x00A0;placed&#x00A0;in&#x00A0;the&#x00A0;function&#x00A0;cell.
</div>
<!--l. 98--><p class="nopar" >If the body is a code-pointer then a special instruction to jump to the start of the code is placed
in the function cell.
<!--l. 103--><p class="noindent" >The Type is recorded on the property list of Fname if it is not an expr.
<!--l. 106--><p class="noindent" >After using putd on Fname, getd will return a pair which specifies the type and the body of the
definition.
<!--l. 109--><p class="noindent" >The following switches are useful when defining functions.
<!--l. 119--><p class="noindent" ><div class="minipage"><a 
 id="dx35-90002"></a>
<span 
class="ptmb7t-x-x-120">*redefmsg </span>= [Initially: t]                                                                                            <span 
class="ptmri7t-x-x-120">switch</span>
<br 
class="newline" />&#x00A0;       &#x00A0;<div class="minipage">If *redefmsg is not nil, the message
<!--l. 119--><p class="noindent" ><span 
class="pcrr7t-x-x-120">&#x22C6;&#x22C6;&#x22C6; Function &#8216;FOO' has been redefined</span>
<!--l. 119--><p class="noindent" >is printed whenever a function is redefined.</div>
</div>
<!--l. 139--><p class="noindent" ><div class="minipage"><a 
 id="dx35-90003"></a>
<span 
class="ptmb7t-x-x-120">*usermode </span>= (Initially: t)                                                                                           <span 
class="ptmri7t-x-x-120">switch</span>
<br 
class="newline" />&#x00A0;       &#x00A0;<div class="minipage">Controls action on redefinition of a function. All functions defined when
*usermode is t are flagged USER. Functions which are flagged USER can
be redefined freely. If an attempt is made to redefine a function which is not
flagged USER, the query
<!--l. 139--><p class="noindent" ><span 
class="pcrr7t-x-x-120">Do you really want to redefine the system function</span>
<span 
class="pcrr7t-x-x-120">FOO?</span>
<!--l. 139--><p class="noindent" >is  made,  requiring  a  Y,  N,  YES,  NO,  or  B  response.  B  starts  the  break
loop,  so  that  one  can  change  the  setting  of  *usermode.  After  exiting  the
break loop, one must answer Y, Yes, N, or No (See yesp in Chapter 12).
If *usermode is nil, all functions can be redefined freely, and all functions
defined have the USER flag removed. This provides some protection from
redefining system functions.</div>
</div>
<!--l. 149--><p class="noindent" ><div class="minipage"><a 
 id="dx35-90004"></a>
<span 
class="ptmb7t-x-x-120">*comp </span>= [Initially: nil]                                                                                               <span 
class="ptmri7t-x-x-120">switch</span>
<br 
class="newline" />&#x00A0;       &#x00A0;<div class="minipage">The  value  of  *comp  controls  whether  or  not  putd  compiles  the  function
before  defining  it.  If  *comp  is  nil  the  function  is  defined  as  a  lambda
expression. If *comp is non-nil, the function is first compiled. Compilation
produces certain changes in the semantics of functions, see Chapter 19 for
information.</div></div>

<!--l. 156--><p class="noindent" ><div class="minipage"><a 
 id="dx35-90005"></a>
<span 
class="ptmb7t-x-x-120">(getd U:any): nil, pair                                                                                                  </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">If U is not the name of a defined function, nil is returned. otherwise (expr,
fexpr, macro, nexpr . code-pointer, lambda) is returned.</div>
</div>
<!--l. 164--><p class="noindent" ><div class="minipage"><a 
 id="dx35-90006"></a>
<span 
class="ptmb7t-x-x-120">(copyd NEW:id OLD:id): NEW:id                                                                             </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Normally the function body and type of NEW become the same as those
of OLD. However, if the switch *comp is set to t and the body of OLD is
not compiled then NEW will be set to the compiled version of the body of
OLD. If no definition exists for OLD an error:</div></div>

<div class="verbatim" id="verbatim-247">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;OLD&#x00A0;has&#x00A0;no&#x00A0;definition&#x00A0;in&#x00A0;COPYD
</div>
<!--l. 167--><p class="nopar" >is given. NEW is returned.
<!--l. 178--><p class="noindent" ><div class="minipage"><a 
 id="dx35-90007"></a>
<span 
class="ptmb7t-x-x-120">(remd U:id): nil, pair                                                                                                   </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Removes the function named U from the set of defined functions. Returns
the (ftype . function) pair or nil, as does getd. If the function type is not
expr then it was recorded on the property list when the function was defined.
In such cases this function removes the type information from the property
list.</div></div>
<h4 class="subsectionHead"><span class="titlemark">8.1.4    </span> <a 
 id="x35-910008.1.4"></a>Function Definition in LISP Syntax</h4>
<!--l. 181--><p class="noindent" >The functions de, df, dn, dm, and ds are used in PSL to define functions and macros.
The functions are compiled if the compiler is loaded and the switch comp is set to
t.
<!--l. 196--><p class="noindent" ><div class="minipage"><a 
 id="dx35-91001"></a>
<span 
class="ptmb7t-x-x-120">(de Fname:id PARAMS:id-list [FN:form]): id                                                       </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Defines the function named Fname, of type expr. The forms FN are made
into a lambda expression with the formal parameter list PARAMS, and this
is used as the body of the function.
<!--l. 196--><p class="noindent" >Previous  definitions  of  the  function  are  lost.  The  name  of  the  defined
function, Fname, is returned.
<!--l. 196--><p class="noindent" >The COMMON module defines the macro DeFun which is equivalent to de.</div>
</div>
<!--l. 207--><p class="noindent" ><div class="minipage"><a 
 id="dx35-91002"></a>
<span 
class="ptmb7t-x-x-120">(df Fname:id PARAM:id-list [FN:form]): id                                                          </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Defines the function named Fname, of type fexpr. The forms FN are made
into a lambda expression with the formal parameter list PARAM, and this is
used as the body of the function. The parameter list should only contain one
parameter.
<!--l. 207--><p class="noindent" >Previous  definitions  of  the  function  are  lost.  The  name  of  the  defined
function, Fname, is returned.</div>
</div>

<!--l. 218--><p class="noindent" ><div class="minipage"><a 
 id="dx35-91003"></a>
<span 
class="ptmb7t-x-x-120">(dn Fname:id PARAM:id-list [FN:form]): id                                                         </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Defines the function named Fname, of type nexpr. The forms FN are made
into a lambda expression with the formal parameter list PARAM, and this is
used as the body of the function. The parameter list should only contain one
parameter.
<!--l. 218--><p class="noindent" >Previous  definitions  of  the  function  are  lost.  The  name  of  the  defined
function, Fname, is returned.</div>
</div>
<!--l. 229--><p class="noindent" ><div class="minipage"><a 
 id="dx35-91004"></a>
<span 
class="ptmb7t-x-x-120">(dm Mname:id PARAM:id-list [FN:form]): id                                                      </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Defines the function named Fname, of type macro. The forms FN are made
into a lambda expression with the formal parameter list PARAM, and this is
used as the body of the function. The parameter list should only contain one
parameter.
<!--l. 229--><p class="noindent" >Previous  definitions  of  the  function  are  lost.  The  name  of  the  defined
function, Fname, is returned.</div>
</div>
<!--l. 231--><p class="noindent" >The function list can be defined as follows

<div class="verbatim" id="verbatim-248">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(dm&#x00A0;list&#x00A0;(a)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(if&#x00A0;(&#x003C;&#x00A0;(length&#x00A0;a)&#x00A0;2)&#x00A0;()
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cons&#x00A0;'cons
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cons&#x00A0;(second&#x00A0;a)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(ncons&#x00A0;(cons&#x00A0;'list&#x00A0;(rest&#x00A0;(rest&#x00A0;a))))))))
</div>
<!--l. 238--><p class="nopar" >Now consider what occurs during the evaluation of (list 1 2). The list (list 1 2) is passed to the
list macro which returns (cons 1 (list 2)) for further evaluation. The evaluator will call the list
macro again for (list 2). This second call on the macro will return (cons 2 (list)). Finally, (list) is
transformed into nil by a third call on the list macro and the entire process will terminate after
evaluating (cons 1 (cons 2 nil)). Notice the lack of distinction between program and data
The data structure representation of the function call is passed to the function as its
parameter.
<!--l. 256--><p class="noindent" ><div class="minipage"><a 
 id="dx35-91005"></a>
<span 
class="ptmb7t-x-x-120">(ds Sname:id PARAMS:id-list [FN:form]): id                                                       </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Defines  the  function  named  Sname  of  type  macro.  The  syntax  of  ds  is
similar to that of de except that a macro is defined instead of an expr.</div>
</div>
<!--l. 258--><p class="noindent" >Perhaps the behavior of this function is best described with an example. The evaluation
of

<div class="verbatim" id="verbatim-249">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(ds&#x00A0;first&#x00A0;(x)&#x00A0;(car&#x00A0;x))
</div>
<!--l. 264--><p class="nopar" >will generate an expression similar to

<div class="verbatim" id="verbatim-250">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(dm&#x00A0;first&#x00A0;(a)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(prog&#x00A0;(x)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;a&#x00A0;(cdr&#x00A0;a))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;x&#x00A0;(car&#x00A0;a))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(return&#x00A0;(list&#x00A0;'car&#x00A0;x))))
</div>
<!--l. 273--><p class="nopar" >which is then evaluated. A sequence of assignment statements are created to initialize each
parameter to its corresponding argument. Each id within the body FN which is not in
the parameter list is quoted. It is an error to call a macro defined this way with more
arguments than are specified by the parameter list. An error of this type will cause the
message

<div class="verbatim" id="verbatim-251">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;Argument&#x00A0;mismatch&#x00A0;in&#x00A0;SMacro&#x00A0;expansion
</div>
<!--l. 284--><p class="nopar" >to be printed. When a call is made without enough arguments the additional parameters are set
to nil.
<!--l. 288--><p class="noindent" >The following macro utilities are in the <span 
class="ptmb7t-x-x-120">useful </span>module.
<!--l. 295--><p class="noindent" ><div class="minipage"><a 
 id="dx35-91006"></a>
<span 
class="ptmb7t-x-x-120">(defmacro A:id B:form [C:form]): id                                                                      </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Defmacro is a useful tool for defining macros. The form of an application of
defmacro is given below, square brackets are used to indicate zero or more
occurances of an expression.</div>
</div>

<div class="verbatim" id="verbatim-252">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(DEFMACRO&#x00A0;&#x003C;name&#x003E;&#x00A0;&#x003C;pattern&#x003E;&#x00A0;[&#x003C;form&#x003E;])
</div>
<!--l. 298--><p class="nopar" >The pattern is an list, each element is either an id or a pair. All of the ids in the pattern are local
variables which may be used freely in the body (the ¡form¿s). When the macro is called the
pattern is matched against the cdr of the macro call, binding the ids of the pattern to their
corresponding parts of the call. Once the binding is complete the body is evaluated, the result is
the value of the last form. Defmacro is often used with backquote. The following
examples illustrate the use of defmacro. The first is intended to provide a contrast with
ds.

<div class="verbatim" id="verbatim-253">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(defmacro&#x00A0;car&#x00A0;(s)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#8216;(car&#x00A0;,s))
</div>
<!--l. 313--><p class="nopar" >

<div class="verbatim" id="verbatim-254">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(defmacro&#x00A0;nth&#x00A0;(s&#x00A0;i)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(if&#x00A0;(onep&#x00A0;i)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#8216;(car&#x00A0;,s)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#8216;(nth&#x00A0;(cdr&#x00A0;,s)&#x00A0;,(sub1&#x00A0;i))))
</div>
<!--l. 319--><p class="nopar" >
<!--l. 336--><p class="noindent" ><div class="minipage"><a 
 id="dx35-91007"></a>
<span 
class="ptmb7t-x-x-120">(deflambda name:id PARAMS:id-list [FN:form]): id                                           </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Defines  the  function  named  name,  of  type  macro.  Deflambda  is  similar
to ds  except  that  the  body  of  the  definition  is  enclosed  within  a  lambda
expression. The number of parameters of the lambda expression is the same
as  the  number  specified  by  PARAMS.  When  the  macro  is  applied  each
of  the  arguments  are  evaluated  and  then  bound  to  the  parameters  of  the
lambda expression. Finally, the body of the lambda is evaluated. Note that
each argument is evaluated once. This may not be true had the macro been
defined using ds. The following example illustrates when deflambda should
be used in place of ds. The expansion of the first version of Check contains
two occurances of (long-calculation n), where the expansion of the second
version only contains one.</div>
</div>

<div class="verbatim" id="verbatim-255">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(ds&#x00A0;check&#x00A0;(any)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(when&#x00A0;(&#x003E;&#x00A0;any&#x00A0;0)&#x00A0;(compute&#x00A0;any)))
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(deflambda&#x00A0;check&#x00A0;(any)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(when&#x00A0;(&#x003E;&#x00A0;any&#x00A0;0)&#x00A0;(compute&#x00A0;any)))
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(check&#x00A0;(long-calculation&#x00A0;n))
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(when&#x00A0;(&#x003E;&#x00A0;(long-calculation&#x00A0;n)&#x00A0;0)&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;Expansion&#x00A0;of&#x00A0;the&#x00A0;first
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(compute&#x00A0;(long-calculation&#x00A0;n)))&#x00A0;&#x00A0;&#x00A0;%&#x00A0;version&#x00A0;of&#x00A0;check
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;((lambda&#x00A0;(any)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;Expansion&#x00A0;of&#x00A0;the&#x00A0;second
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(when&#x00A0;(&#x003E;&#x00A0;any&#x00A0;0)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;version&#x00A0;of&#x00A0;check
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(compute&#x00A0;any)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(long-calculation&#x00A0;n))
</div>
<!--l. 353--><p class="nopar" >
<!--l. 355--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">8.1.5    </span> <a 
 id="x35-920008.1.5"></a>BackQuote</h4>
<!--l. 364--><p class="noindent" ><div class="minipage"><a 
 id="dx35-92001"></a>
<span 
class="ptmb7t-x-x-120">(backquote A:form): form                                                                                        </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Backquote is the function name for &#8216; (accent grave). With some printers
it may  be  difficult  to  distinguish  between  the  quote  and  accent  grave
characters.  For  this  reason,  in  the  examples  which  follow  &#8217;expression  is
written as (quote expression). You must load USEFUL to define backquote.</div>
</div>In the previous section the function list was defined as a macro.

<div class="verbatim" id="verbatim-256">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(dm&#x00A0;list&#x00A0;(a)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(if&#x00A0;(&#x003C;&#x00A0;(length&#x00A0;a)&#x00A0;2)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;()
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cons&#x00A0;(quote&#x00A0;cons)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cons&#x00A0;(second&#x00A0;a)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(ncons&#x00A0;(cons&#x00A0;(quote&#x00A0;list)(rest&#x00A0;(rest&#x00A0;a))))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;))))
</div>
<!--l. 376--><p class="nopar" >The body of this definition is somewhat difficult to read. An abbreviated syntax was developed
to aid both the writer and the reader. The notation, called &#8221;backquote&#8221; (&#8216;), works as an
&#8221;anti-quote&#8221;. Unquoted forms within its scope are assumed to be constants. To indicate that a
form should be evaluated, one should prefix the form with a comma (,). Consider the redefinition
of the macro list.

<div class="verbatim" id="verbatim-257">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(dm&#x00A0;list&#x00A0;(a)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(if&#x00A0;(&#x003C;&#x00A0;(length&#x00A0;a)&#x00A0;2)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;()
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#8216;(cons&#x00A0;,(second&#x00A0;a)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;,(cons&#x00A0;(quote&#x00A0;list)&#x00A0;(rest&#x00A0;(rest&#x00A0;a))))))
</div>
<!--l. 391--><p class="nopar" >While this is an improvement, the explicit construction ,(cons (quote list) (rest (rest a))) clutters
up the appearance. The application of cons is there to indicate that we want to combine the result
of (rest (rest a)) with the identifier list. The form ,(list (rest (rest a)) will not give this effect,
instead it would create a list of two elements. The at-sign (@) is used in conjunction with
the comma to mean &#8221;splice-in&#8221; rather than &#8221;cons-in&#8221;. This results in the following
defintion.

<div class="verbatim" id="verbatim-258">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(dm&#x00A0;list&#x00A0;(a)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(if&#x00A0;(&#x003C;&#x00A0;(length&#x00A0;a)&#x00A0;2)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;()
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#8216;(cons&#x00A0;,(second&#x00A0;a)&#x00A0;(list&#x00A0;,@(rest&#x00A0;(rest&#x00A0;a))))))
</div>
<!--l. 407--><p class="nopar" >
<!--l. 412--><p class="noindent" ><div class="minipage"><a 
 id="dx35-92002"></a>
<span 
class="ptmb7t-x-x-120">(unquote A:any): Undefined                                                                                      </span><span 
class="ptmri7t-x-x-120">fexpr</span>
<br 
class="newline" /><div class="minipage">Function name for comma ,. It is an error to eval this function; it should
occur only inside a backquote.</div>
</div>
<!--l. 417--><p class="noindent" ><div class="minipage"><a 
 id="dx35-92003"></a>
<span 
class="ptmb7t-x-x-120">(unquotel A:any): Undefined                                                                                     </span><span 
class="ptmri7t-x-x-120">fexpr</span>
<br 
class="newline" /><div class="minipage">Function name for comma-atsign ,@. It is an error to eval this function; it
should only occur inside a backquote.</div>
</div>The two examples which follow are similar definitions of an arithmetic if form. There are four
arguments: a test form, a negative form, a zero form, and a positive form. One of the last three
forms is chosen to be evaluated according to whether the test form is positive, negative, or zero.
The first uses the traditional dm while the second uses defmacro and backquote. Clearly the
second is much simpler. To clarify printer output, there are no occurances of the accent grave
character in the first definition and the second definition does not contain an occurance of the
quote character.

<div class="verbatim" id="verbatim-259">
(dm&#x00A0;number-if&#x00A0;(calling-form)
&#x00A0;<br />&#x00A0;&#x00A0;(list&#x00A0;'let
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;'((var&#x00A0;(gensym)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(list&#x00A0;'let
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(list&#x00A0;(list&#x00A0;'var&#x00A0;(nth&#x00A0;calling-form&#x00A0;2)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(list&#x00A0;'cond
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(list&#x00A0;(list&#x00A0;'minusp&#x00A0;'var)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(nth&#x00A0;calling-form&#x00A0;3))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(list&#x00A0;(list&#x00A0;'zerop&#x00A0;'var)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(nth&#x00A0;calling-form&#x00A0;4))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(list&#x00A0;t&#x00A0;(nth&#x00A0;calling-form&#x00A0;5))))))
&#x00A0;<br />
&#x00A0;<br />(defmacro&#x00A0;number-if&#x00A0;(test&#x00A0;minus-form&#x00A0;zero-form&#x00A0;plus-form)
&#x00A0;<br />&#x00A0;&#x00A0;(let&#x00A0;((var&#x00A0;(gensym)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#8216;(let&#x00A0;((,var&#x00A0;,test))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;((minusp&#x00A0;,var)&#x00A0;,minus-form)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((zerop&#x00A0;,var)&#x00A0;,zero-form)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(t&#x00A0;,plus-form)))))
</div>
<!--l. 448--><p class="nopar" >
<!--l. 450--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">8.1.6    </span> <a 
 id="x35-930008.1.6"></a>MacroExpand</h4>
<!--l. 463--><p class="noindent" ><div class="minipage"><a 
 id="dx35-93001"></a>
<span 
class="ptmb7t-x-x-120">(macroexpand A:form [B:id]): form                                                                       </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Macroexpand  is  a  useful  tool  for  debugging  macro  definitions.  If  given
one  argument,  macroexpand  expands  all  the  macros  in  that  form.  Often
one  wishes  for  more  control  over  this  process.  For  example,  if  a  macro
expands into a let, we may not wish to see the let itself expanded to a lambda
expression. Therefore additional arguments may be given to macroexpand.
If these are supplied, they should be the names of macros, and only those
specified are expanded.</div>
</div>
<!--l. 465--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
 id="x35-940008.1.6"></a>Low Level Function Definition Primitives</h5>
<!--l. 467--><p class="noindent" >The following functions are used especially by putd and Getd, defined above in Section 9.1.3,
and by eval and apply, defined in Chapter 11.

<!--l. 480--><p class="noindent" ><div class="minipage"><a 
 id="dx35-94001"></a>
<span 
class="ptmb7t-x-x-120">(funboundp U:id): boolean                                                                                         </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Tests whether there is a definition in the function cell of U; returns nil if so,
t if not.
<!--l. 480--><p class="noindent" >Note: The functional value of an identifier which does not define a function
is actually a call on undefinedfunction. The evaluation of undefinedfunction
will result in a continuable error.</div></div>
<!--l. 486--><p class="noindent" ><div class="minipage"><a 
 id="dx35-94002"></a>
<span 
class="ptmb7t-x-x-120">(fboundp U:id): boolean                                                                                           </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Equivalent to (not (funboundp U)), the function funboundp is described
above.</div></div>
<!--l. 493--><p class="noindent" ><div class="minipage"><a 
 id="dx35-94003"></a>
<span 
class="ptmb7t-x-x-120">(flambdalinkp U:id): boolean                                                                                     </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Tests whether U is an interpreted function; return t if so, nil if not. This is
done by checking for the special code-address of the lambdalink function,
which calls the interpreter.</div>
</div>
<!--l. 498--><p class="noindent" ><div class="minipage"><a 
 id="dx35-94004"></a>
<span 
class="ptmb7t-x-x-120">(fcodep U:id): boolean                                                                                                 </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Tests whether U is a compiled function; returns t if so, nil if not.
</div></div>
<!--l. 505--><p class="noindent" ><div class="minipage"><a 
 id="dx35-94005"></a>
<span 
class="ptmb7t-x-x-120">(makefunbound U:id): nil                                                                                           </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Makes U an undefined function by planting a special call to the function,
undefinedfunction, in the function cell of U. See funboundp above for more
information about undefinedfunction.</div></div>
<!--l. 511--><p class="noindent" ><div class="minipage"><a 
 id="dx35-94006"></a>
<span 
class="ptmb7t-x-x-120">(makeflambdalink U:id): nil                                                                                       </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Makes U an interpreted function by planting a special call to an interpreter
support function (lambdalink) function in the function cell of U.</div>
</div>

<!--l. 516--><p class="noindent" ><div class="minipage"><a 
 id="dx35-94007"></a>
<span 
class="ptmb7t-x-x-120">(makefcode U:id C:code-pointer): nil                                                                        </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Makes  U  a  compiled  function  by  planting  a  special  JUMP  to  the
code-address associated with C.</div></div>
<!--l. 520--><p class="noindent" ><div class="minipage"><a 
 id="dx35-94008"></a>
<span 
class="ptmb7t-x-x-120">(getfcodepointer U:id): code-pointer                                                                         </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Gets the code-pointer for U.
</div></div>
<!--l. 527--><p class="noindent" ><div class="minipage"><a 
 id="dx35-94009"></a>
<span 
class="ptmb7t-x-x-120">(code-number-of-arguments C:code-pointer): </span><span 
class="cmsy-10x-x-120">{</span><span 
class="ptmb7t-x-x-120">nil,integer</span><span 
class="cmsy-10x-x-120">}            </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Some compiled functions have the argument number they expect stored in
association with the code-pointer C. This integer, or nil is returned.</div>
</div>
<h4 class="subsectionHead"><span class="titlemark">8.1.7    </span> <a 
 id="x35-950008.1.7"></a>Function Type Predicates</h4>
<!--l. 533--><p class="noindent" ><div class="minipage"><a 
 id="dx35-95001"></a>
<span 
class="ptmb7t-x-x-120">(exprp U:any): boolean                                                                                                </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Test if U is a code-pointer, lambda form, or an id with expr definition.
</div></div>
<!--l. 537--><p class="noindent" ><div class="minipage"><a 
 id="dx35-95002"></a>
<span 
class="ptmb7t-x-x-120">(fexprp U:any): boolean                                                                                              </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Test if U is an id with fexpr definition.
</div></div>
<!--l. 541--><p class="noindent" ><div class="minipage"><a 
 id="dx35-95003"></a>
<span 
class="ptmb7t-x-x-120">(nexprp U:any): boolean                                                                                             </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Test if U is an id with nexpr definition.
</div></div>
<!--l. 545--><p class="noindent" ><div class="minipage"><a 
 id="dx35-95004"></a>
<span 
class="ptmb7t-x-x-120">(macrop U:any): boolean                                                                                            </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Test if U is an id with macro definition.
</div></div>


<!--l. 547--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li7.html#allman1se25.html" >Up</a></td><td class="clinks"><a 
href="allman1se26.html" >Next</a></td><td class="clinks"><a 
href="allman1se25.html" >Front</a></td></tr></table><a 
 id="tailallman1se25.html"></a>   
</body></html> 
